#!/usr/bin/env python3
"""
testing-scenario:-python-web-agent - Autonomous Goal-Seeking Agent

Generated by Amplihack Goal Agent Generator
"""

import sys
from pathlib import Path

# Add parent directory to path for amplihack imports
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from amplihack.launcher.auto_mode import AutoMode
except ImportError:
    print("Error: amplihack package not found")
    print("Install with: pip install amplihack")
    sys.exit(1)


def main():
    """Execute the goal-seeking agent."""
    # Load configuration
    config = {
        "max_turns": 6,
        "initial_prompt": '# Goal: Scenario: Python Web Application on Azure App Service\n\n## Objective\n# Scenario: Python Web Application on Azure App Service\n\n## Technology Area\nCompute\n\n## Company Profile\n- **Company Size**: Small startup\n- **Industry**: Data Analytics / SaaS\n- **Use Case**: Deploy a Python Flask web application with continuous deployment and auto-scaling\n\n## Scenario Description\nDeploy a Python Flask-based web application to Azure App Service with automatic scaling, continuous integration from Git, environment configuration, and monitoring. This scenario covers serverless compute management without VM overhead.\n\n## Azure Services Used\n- Azure App Service (Web Apps)\n- Azure App Service Plan\n- Azure Container Registry (optional)\n- Azure Application Insights\n- Azure Log Analytics Workspace\n\n## Prerequisites\n- Azure subscription with Contributor role\n- Azure CLI installed and configured\n- Git installed locally\n- Python 3.9+ installed (for local development/testing)\n- A GitHub account or Git repository access (for deployment)\n\n---\n\n## Phase 1: Deployment and Validation\n\n### Environment Setup\n```bash\n# Set variables\nUNIQUE_ID=$(date +%Y%m%d%H%M%S)\nRESOURCE_GROUP="azurehaymaker-compute-${UNIQUE_ID}-rg"\nLOCATION="eastus"\nAPP_SERVICE_PLAN="azurehaymaker-asp-${UNIQUE_ID}"\nWEB_APP_NAME="azurehaymaker-py-app-${UNIQUE_ID}"\nAPP_INSIGHTS_NAME="azurehaymaker-appinsights-${UNIQUE_ID}"\nLOG_ANALYTICS_NAME="azurehaymaker-logs-${UNIQUE_ID}"\nSTORAGE_ACCOUNT="azurehaymaker${UNIQUE_ID}"\nARTIFACT_DIR="/tmp/azurehaymaker-flask-app"\n\n# Tags\nTAGS="AzureHayMaker-managed=true Scenario=compute-app-service-python Owner=AzureHayMaker"\n```\n\n### Deployment Steps\n```bash\n# Step 1: Create Resource Group\naz group create \\\n  --name "${RESOURCE_GROUP}" \\\n  --location "${LOCATION}" \\\n  --tags ${TAGS}\n\n# Step 2: Create Log Analytics Workspace for monitoring\naz monitor log-analytics workspace create \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --workspace-name "${LOG_ANALYTICS_NAME}" \\\n  --location "${LOCATION}" \\\n  --tags ${TAGS}\n\nLOG_ANALYTICS_ID=$(az monitor log-analytics workspace show \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --workspace-name "${LOG_ANALYTICS_NAME}" \\\n  --query customerId -o tsv)\n\nLOG_ANALYTICS_KEY=$(az monitor log-analytics workspace get-shared-keys \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --workspace-name "${LOG_ANALYTICS_NAME}" \\\n  --query primarySharedKey -o tsv)\n\n# Step 3: Create Application Insights for monitoring\naz monitor app-insights component create \\\n  --app "${APP_INSIGHTS_NAME}" \\\n  --location "${LOCATION}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --application-type web \\\n  --workspace "${LOG_ANALYTICS_NAME}" \\\n  --tags ${TAGS}\n\nINSTRUMENTATION_KEY=$(az monitor app-insights component show \\\n  --app "${APP_INSIGHTS_NAME}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --query instrumentationKey -o tsv)\n\n# Step 4: Create App Service Plan (B1 Basic tier for small apps)\naz appservice plan create \\\n  --name "${APP_SERVICE_PLAN}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --sku B1 \\\n  --is-linux \\\n  --tags ${TAGS}\n\n# Step 5: Create the Web App with Python runtime\naz webapp create \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --plan "${APP_SERVICE_PLAN}" \\\n  --name "${WEB_APP_NAME}" \\\n  --runtime "PYTHON|3.9" \\\n  --tags ${TAGS}\n\n# Step 6: Configure application settings\naz webapp config appsettings set \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${WEB_APP_NAME}" \\\n  --settings "APPINSIGHTS_INSTRUMENTATIONKEY=${INSTRUMENTATION_KEY}" \\\n  "ApplicationInsightsAgent_EXTENSION_VERSION=~3" \\\n  "XDT_MicrosoftApplicationInsights_Mode=default"\n\n# Step 7: Create the Flask application files locally\nmkdir -p "${ARTIFACT_DIR}"\n\n# Create requirements.txt\ncat > "${ARTIFACT_DIR}/requirements.txt" <<\'EOF\'\nFlask==3.0.0\ngunicorn==21.2.0\napplicationinsights==0.11.10\npython-dotenv==1.0.0\nEOF\n\n# Create main Flask application\ncat > "${ARTIFACT_DIR}/app.py" <<\'EOF\'\nimport os\nfrom datetime import datetime\nfrom flask import Flask, jsonify\nfrom applicationinsights import TelemetryClient\n\napp = Flask(__name__)\n\n# Application Insights telemetry client\ntc = TelemetryClient(os.environ.get(\'APPINSIGHTS_INSTRUMENTATIONKEY\', \'\'))\n\n@app.route(\'/\')\ndef home():\n    """Root endpoint returning welcome page"""\n    tc.track_pageview(\'home\')\n    return f\'\'\'\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <title>Azure HayMaker - Python App Service</title>\n        <style>\n            body {{ font-family: Segoe UI, sans-serif; margin: 50px; background: #f5f5f5; }}\n            .container {{ max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 5px; }}\n            h1 {{ color: #0078d4; }}\n            .info {{ background: #f0f0f0; padding: 15px; border-left: 4px solid #0078d4; }}\n        </style>\n    </head>\n    <body>\n        <div class="container">\n            <h1>Azure HayMaker - Python Web App</h1>\n            <div class="info">\n                <p><strong>Scenario:</strong> compute-03-app-service-python</p>\n                <p><strong>Framework:</strong> Flask 3.0</p>\n                <p><strong>Runtime:</strong> Python 3.9</p>\n                <p><strong>Timestamp:</strong> {datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')}</p>\n                <p><strong>Hostname:</strong> {os.environ.get(\'COMPUTERNAME\', \'Azure App Service\')}</p>\n            </div>\n            <hr>\n            <p>\n                <a href="/api/health">Health Check</a> |\n                <a href="/api/info">System Info</a> |\n                <a href="/api/status">Status</a>\n            </p>\n        </div>\n    </body>\n    </html>\n    \'\'\', 200, {\'Content-Type\': \'text/html\'}\n\n@app.route(\'/api/health\')\ndef health():\n    """Health check endpoint"""\n    tc.track_event(\'health_check\')\n    return jsonify({\n        \'status\': \'healthy\',\n        \'timestamp\': datetime.now().isoformat(),\n        \'service\': \'Azure App Service - Python\'\n    }), 200\n\n@app.route(\'/api/info\')\ndef info():\n    """System information endpoint"""\n    tc.track_event(\'info_request\')\n    return jsonify({\n        \'app\': \'Azure HayMaker Python Web App\',\n        \'scenario\': \'compute-03-app-service-python\',\n        \'framework\': \'Flask\',\n        \'python_version\': os.sys.version,\n        \'environment\': os.environ.get(\'AZURE_APP_SERVICE\', \'Unknown\'),\n        \'timestamp\': datetime.now().isoformat()\n    }), 200\n\n@app.route(\'/api/status\')\ndef status():\n    """Application status endpoint"""\n    tc.track_event(\'status_request\')\n    return jsonify({\n        \'running\': True,\n        \'app_service\': \'Azure App Service\',\n        \'deployment_slot\': os.environ.get(\'WEBSITE_SLOT_NAME\', \'production\'),\n        \'timestamp\': datetime.now().isoformat()\n    }), 200\n\n@app.route(\'/api/echo/<message>\')\ndef echo(message):\n    """Echo endpoint for testing"""\n    tc.track_event(\'echo\', {\'message\': message})\n    return jsonify({\n        \'echo\': message,\n        \'timestamp\': datetime.now().isoformat()\n    }), 200\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({\'error\': \'Not Found\', \'message\': str(error)}), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    tc.track_exception()\n    return jsonify({\'error\': \'Internal Server Error\', \'message\': str(error)}), 500\n\nif __name__ == \'__main__\':\n    app.run(debug=False, host=\'0.0.0.0\', port=8000)\nEOF\n\n# Create runtime configuration\ncat > "${ARTIFACT_DIR}/.runtime" <<\'EOF\'\npython-3.9\nEOF\n\n# Create Procfile for gunicorn\ncat > "${ARTIFACT_DIR}/Procfile" <<\'EOF\'\nweb: gunicorn --bind 0.0.0.0 --workers 4 --timeout 60 app:app\nEOF\n\n# Step 8: Initialize git repository\ncd "${ARTIFACT_DIR}"\ngit init\ngit add .\ngit commit -m "Initial Flask application commit for Azure App Service"\n\n# Step 9: Configure local Git deployment\naz webapp deployment user set --user-name "azureuser" --password "HayMaker$(openssl rand -hex 6)"\n\n# Step 10: Get the Git URL for the web app\nGIT_URL=$(az webapp deployment source config-local-git \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${WEB_APP_NAME}" \\\n  --query url -o tsv)\n\necho "Git deployment URL: ${GIT_URL}"\n\n# Step 11: Add Azure remote and push\ncd "${ARTIFACT_DIR}"\ngit remote add azure "${GIT_URL}"\ngit push azure master 2>&1 || git push azure main 2>&1 || echo "Push attempted"\n\n# Step 12: Configure auto-scaling settings\naz monitor autoscale create \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --resource "${APP_SERVICE_PLAN}" \\\n  --resource-type "Microsoft.Web/serverfarms" \\\n  --name "azurehaymaker-autoscale-${UNIQUE_ID}" \\\n  --min-count 1 \\\n  --max-count 5 \\\n  --count 1\n\n# Step 13: Enable Application Insights\naz webapp config set \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${WEB_APP_NAME}" \\\n  --use-32bit-worker-process false\n\n# Step 14: Wait for deployment to complete\necho "Waiting for application deployment..."\nsleep 60\n```\n\n### Validation\n```bash\n# Verify Resource Group\naz group show --name "${RESOURCE_GROUP}"\n\n# Verify App Service Plan\naz appservice plan show --resource-group "${RESOURCE_GROUP}" --name "${APP_SERVICE_PLAN}"\n\n# Verify Web App\naz webapp show --resource-group "${RESOURCE_GROUP}" --name "${WEB_APP_NAME}"\n\n# Get the web app URL\nWEB_APP_URL=$(az webapp show \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${WEB_APP_NAME}" \\\n  --query defaultHostName -o tsv)\n\necho "Web App URL: https://${WEB_APP_URL}"\n\n# Test the application\ncurl -I "https://${WEB_APP_URL}" || echo "Note: App may still be deploying"\n\n# Test health endpoint\ncurl "https://${WEB_APP_URL}/api/health"\n\n# List all resources\naz resource list --resource-group "${RESOURCE_GROUP}" --output table\n```\n\n---\n\n## Phase 2: Mid-Day Operations and Management\n\n### Management Operations\n```bash\n# Operation 1: Monitor application performance\naz monitor metrics list \\\n  --resource "/subscriptions/$(az account show --query id -o tsv)/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Web/sites/${WEB_APP_NAME}" \\\n  --metric "CpuTime" \\\n  --start-time $(date -u -d \'1 hour ago\' \'+%Y-%m-%dT%H:%M:%SZ\') \\\n  --end-time $(date -u \'+%Y-%m-%dT%H:%M:%SZ\')\n\n# Operation 2: Check HTTP request metrics\naz monitor metrics list \\\n  --resource "/subscriptions/$(az account show --query id -o tsv)/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Web/sites/${WEB_APP_NAME}" \\\n  --metric "Requests" \\\n  --start-time $(date -u -d \'1 hour ago\' \'+%Y-%m-%dT%H:%M:%SZ\') \\\n  --end-time $(date -u \'+%Y-%m-%dT%H:%M:%SZ\')\n\n# Operation 3: View application logs\naz webapp log tail --resource-group "${RESOURCE_GROUP}" --name "${WEB_APP_NAME}" --lines 50\n\n# Operation 4: Restart the web app\naz webapp restart --resource-group "${RESOURCE_GROUP}" --name "${WEB_APP_NAME}"\n\n# Operation 5: Update application settings\naz webapp config appsettings set \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${WEB_APP_NAME}" \\\n  --settings "FLASK_ENV=production" "DEBUG=False"\n\n# Operation 6: Enable diagnostics logging\naz webapp log config \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${WEB_APP_NAME}" \\\n  --application-logging true \\\n  --level verbose\n\n# Operation 7: Check deployment status and history\naz webapp deployment list --resource-group "${RESOURCE_GROUP}" --name "${WEB_APP_NAME}" --output table\n\n# Operation 8: View Application Insights traces\naz monitor app-insights query \\\n  --app "${APP_INSIGHTS_NAME}" \\\n  --analytics-query "traces | take 10"\n\n# Operation 9: Test API endpoints\nWEB_APP_URL=$(az webapp show --resource-group "${RESOURCE_GROUP}" --name "${WEB_APP_NAME}" --query defaultHostName -o tsv)\necho "Testing API endpoints..."\ncurl "https://${WEB_APP_URL}/api/info"\ncurl "https://${WEB_APP_URL}/api/status"\ncurl "https://${WEB_APP_URL}/api/echo/test-message"\n\n# Operation 10: Scale up the App Service Plan\naz appservice plan update \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE_PLAN}" \\\n  --sku S1\n\n# Operation 11: View auto-scale settings\naz monitor autoscale show \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "azurehaymaker-autoscale-${UNIQUE_ID}"\n\n# Operation 12: Check application deployment slots\naz webapp deployment slot list --resource-group "${RESOURCE_GROUP}" --name "${WEB_APP_NAME}" --output table\n\n# Operation 13: Update Python runtime version\naz webapp config set \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${WEB_APP_NAME}" \\\n  --linux-fx-version "PYTHON|3.10"\n\n# Operation 14: Monitor HTTP response times\naz monitor metrics list \\\n  --resource "/subscriptions/$(az account show --query id -o tsv)/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Web/sites/${WEB_APP_NAME}" \\\n  --metric "ResponseTime" \\\n  --start-time $(date -u -d \'30 minutes ago\' \'+%Y-%m-%dT%H:%M:%SZ\') \\\n  --end-time $(date -u \'+%Y-%m-%dT%H:%M:%SZ\')\n```\n\n---\n\n## Phase 3: Cleanup and Tear-Down\n\n### Cleanup Steps\n```bash\n# Step 1: Delete the entire resource group (includes app service, app insights, etc.)\naz group delete \\\n  --name "${RESOURCE_GROUP}" \\\n  --yes \\\n  --no-wait\n\n# Step 2: Wait for deletion to complete\necho "Waiting for resource group deletion..."\nsleep 120\n\n# Step 3: Verify deletion\naz group exists --name "${RESOURCE_GROUP}"\n\n# Step 4: Confirm cleanup\necho "Verifying cleanup..."\naz resource list --resource-group "${RESOURCE_GROUP}" 2>&1 | grep "could not be found" && echo "âœ“ Resource group successfully deleted"\n\n# Step 5: Clean up local files\nrm -rf "${ARTIFACT_DIR}"\n```\n\n---\n\n## Resource Naming Convention\n- Resource Group: `azurehaymaker-compute-${UNIQUE_ID}-rg`\n- App Service Plan: `azurehaymaker-asp-${UNIQUE_ID}`\n- Web App: `azurehaymaker-py-app-${UNIQUE_ID}`\n- Application Insights: `azurehaymaker-appinsights-${UNIQUE_ID}`\n- Log Analytics: `azurehaymaker-logs-${UNIQUE_ID}`\n\nAll resources tagged with: `AzureHayMaker-managed=true`\n\n---\n\n## Documentation References\n- [Azure App Service Overview](https://learn.microsoft.com/en-us/azure/app-service/overview)\n- [Create Python Web App on App Service](https://learn.microsoft.com/en-us/azure/app-service/quickstart-python)\n- [Configure Python Apps on App Service](https://learn.microsoft.com/en-us/azure/app-service/configure-language-python)\n- [Flask Documentation](https://flask.palletsprojects.com/)\n- [Application Insights for Python](https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)\n- [App Service Auto-Scale](https://learn.microsoft.com/en-us/azure/app-service/manage-scale-up)\n\n---\n\n## Automation Tool\n**Recommended**: Azure CLI with Git\n\n**Rationale**: Azure CLI provides comprehensive App Service management while Git enables continuous deployment. This serverless compute approach eliminates VM management overhead while maintaining full scalability.\n\n---\n\n## Estimated Duration\n- **Deployment**: 15-20 minutes\n- **Operations Phase**: 8+ hours (with monitoring, scaling, and application updates)\n- **Cleanup**: 5-10 minutes\n\n---\n\n## Notes\n- Flask application includes health check, info, and status endpoints\n- Application Insights integration for automatic performance monitoring\n- Auto-scaling configured to handle traffic spikes (1-5 instances)\n- Local Git deployment used for quick iteration\n- Python 3.9 runtime selected for stability and support\n- gunicorn used as production WSGI server\n- All operations scoped to single tenant and subscription\n- Application designed for microservices and API-first architecture\n\n\n## Execution Plan\n\n### Phase 1: Test Planning\nPlan test strategy\n**Estimated Duration**: 5 minutes\n**Required Capabilities**: test-design, planning\n\n### Phase 2: Test Implementation\nImplement test cases\n**Estimated Duration**: 5 minutes\n**Required Capabilities**: test-coding, framework-setup\n**Dependencies**: Test Planning\n\n### Phase 3: Test Execution\nRun test suite\n**Estimated Duration**: 5 minutes\n**Required Capabilities**: test-execution, automation\n**Dependencies**: Test Implementation\n\n### Phase 4: Results Analysis\nAnalyze test results\n**Estimated Duration**: 5 minutes\n**Required Capabilities**: analysis, reporting\n**Dependencies**: Test Execution\n\n## Success Criteria\n- Goal \'Scenario: Python Web Application on Azure App Serv...\' is achieved\n\n## Instructions\nExecute the plan above autonomously:\n1. Follow each phase in sequence\n2. Use available skills and tools\n3. Verify success criteria are met\n4. Report progress and completion',
        "working_dir": ".",
        "sdk": "claude",
        "ui_mode": False,
        "success_criteria": [
            "Goal 'Scenario: Python Web Application on Azure App Serv...' is achieved"
        ],
        "constraints": [],
    }

    # Read initial prompt
    prompt_path = Path(__file__).parent / "prompt.md"
    if not prompt_path.exists():
        print("Error: prompt.md not found")
        sys.exit(1)

    initial_prompt = prompt_path.read_text()

    # Create auto-mode instance
    auto_mode = AutoMode(
        sdk=config.get("sdk", "claude"),
        prompt=initial_prompt,
        max_turns=config.get("max_turns", 10),
        working_dir=Path(__file__).parent,
        ui_mode=config.get("ui_mode", False),
    )

    # Run agent
    print("Starting testing-scenario:-python-web-agent...")
    print("Goal: Scenario: Python Web Application on Azure App Service")
    print("Estimated duration: 22 minutes")
    print()

    exit_code = auto_mode.run()

    if exit_code == 0:
        print("\nGoal achieved successfully!")
    else:
        print(f"\nGoal execution failed with code {exit_code}")

    return exit_code


if __name__ == "__main__":
    sys.exit(main())
