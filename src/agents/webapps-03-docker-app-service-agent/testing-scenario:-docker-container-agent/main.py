#!/usr/bin/env python3
"""
testing-scenario:-docker-container-agent - Autonomous Goal-Seeking Agent

Generated by Amplihack Goal Agent Generator
"""

import sys
from pathlib import Path

# Add parent directory to path for amplihack imports
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from amplihack.launcher.auto_mode import AutoMode
except ImportError:
    print("Error: amplihack package not found")
    print("Install with: pip install amplihack")
    sys.exit(1)


def main():
    """Execute the goal-seeking agent."""
    # Load configuration
    config = {
        "max_turns": 18,
        "initial_prompt": '# Goal: Scenario: Docker Container on Azure App Service\n\n## Objective\n# Scenario: Docker Container on Azure App Service\n\n## Technology Area\nWeb Apps\n\n## Company Profile\n- **Company Size**: Small to mid-size development company\n- **Industry**: Technology / DevOps\n- **Use Case**: Deploy containerized web applications with orchestration simplicity\n\n## Scenario Description\nDeploy Docker containers directly to Azure App Service without Kubernetes complexity. Build custom container images, push to registry, and automatically update deployments with new images.\n\n## Azure Services Used\n- Azure App Service (hosting)\n- Azure App Service Plan (compute)\n- Azure Container Registry (image storage)\n- Azure Application Insights (monitoring)\n\n## Prerequisites\n- Azure subscription with Contributor role\n- Azure CLI installed with Docker\n- Docker installed and running\n- A unique identifier for this scenario run\n\n---\n\n## Phase 1: Deployment and Validation\n\n### Environment Setup\n```bash\n# Set variables\nUNIQUE_ID=$(date +%Y%m%d%H%M%S)\nRESOURCE_GROUP="azurehaymaker-webapp-docker-${UNIQUE_ID}-rg"\nLOCATION="eastus"\nAPP_SERVICE_PLAN="azurehaymaker-plan-${UNIQUE_ID}"\nAPP_SERVICE="azurehaymaker-docker-${UNIQUE_ID}"\nACR_REGISTRY="azmkrdocker${UNIQUE_ID}"\nINSIGHTS_NAME="azurehaymaker-insights-${UNIQUE_ID}"\n\n# Tags\nTAGS="AzureHayMaker-managed=true Scenario=webapps-docker Owner=AzureHayMaker"\n```\n\n### Deployment Steps\n```bash\n# Step 1: Create Resource Group\naz group create \\\n  --name "${RESOURCE_GROUP}" \\\n  --location "${LOCATION}" \\\n  --tags ${TAGS}\n\n# Step 2: Create Azure Container Registry\naz acr create \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${ACR_REGISTRY}" \\\n  --sku Standard \\\n  --admin-enabled true \\\n  --tags ${TAGS}\n\n# Step 3: Create Dockerfile for custom app\ncat > /tmp/Dockerfile <<EOF\nFROM python:3.11-slim\nWORKDIR /app\nRUN pip install flask\n\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\n\nCOPY app.py .\n\nEXPOSE 8080\nENV FLASK_APP=app.py\nCMD ["gunicorn", "--bind", "0.0.0.0:8080", "app:app"]\nEOF\n\ncat > /tmp/requirements.txt <<EOF\nflask==2.3.0\ngunicorn==20.1.0\nEOF\n\ncat > /tmp/app.py <<EOF\nfrom flask import Flask, jsonify\nimport os\n\napp = Flask(__name__)\n\n@app.route(\'/\')\ndef hello():\n    return jsonify({\n        \'message\': \'Azure HayMaker Docker App\',\n        \'scenario\': \'webapps-docker-app-service\',\n        \'environment\': os.environ.get(\'ENVIRONMENT\', \'production\')\n    })\n\n@app.route(\'/health\')\ndef health():\n    return jsonify({\'status\': \'healthy\'})\n\n@app.route(\'/api/info\')\ndef info():\n    return jsonify({\n        \'app\': \'Docker Container App\',\n        \'version\': \'1.0.0\',\n        \'platform\': \'Azure App Service\'\n    })\n\nif __name__ == \'__main__\':\n    app.run(host=\'0.0.0.0\', port=8080)\nEOF\n\n# Step 4: Build Docker image\ndocker build -t "${ACR_REGISTRY}.azurecr.io/webapp:v1" -f /tmp/Dockerfile /tmp/\n\n# Step 5: Get ACR credentials\nACR_USERNAME=$(az acr credential show \\\n  --name "${ACR_REGISTRY}" \\\n  --query username -o tsv)\n\nACR_PASSWORD=$(az acr credential show \\\n  --name "${ACR_REGISTRY}" \\\n  --query passwords[0].value -o tsv)\n\nACR_LOGIN_SERVER=$(az acr show \\\n  --name "${ACR_REGISTRY}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --query loginServer -o tsv)\n\n# Step 6: Push image to ACR\ndocker login "${ACR_LOGIN_SERVER}" -u "${ACR_USERNAME}" -p "${ACR_PASSWORD}"\ndocker push "${ACR_LOGIN_SERVER}/webapp:v1"\n\n# Step 7: Create Application Insights\naz monitor app-insights component create \\\n  --app "${INSIGHTS_NAME}" \\\n  --location "${LOCATION}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --application-type web \\\n  --tags ${TAGS}\n\nINSIGHTS_KEY=$(az monitor app-insights component show \\\n  --app "${INSIGHTS_NAME}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --query "instrumentationKey" -o tsv)\n\n# Step 8: Create App Service Plan for Linux\naz appservice plan create \\\n  --name "${APP_SERVICE_PLAN}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --location "${LOCATION}" \\\n  --sku B2 \\\n  --is-linux \\\n  --tags ${TAGS}\n\n# Step 9: Create App Service with Docker container\naz webapp create \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --plan "${APP_SERVICE_PLAN}" \\\n  --name "${APP_SERVICE}" \\\n  --deployment-container-image-name "${ACR_LOGIN_SERVER}/webapp:v1" \\\n  --docker-registry-server-url "https://${ACR_LOGIN_SERVER}" \\\n  --docker-registry-server-user "${ACR_USERNAME}" \\\n  --docker-registry-server-password "${ACR_PASSWORD}" \\\n  --tags ${TAGS}\n\n# Step 10: Configure app settings\naz webapp config appsettings set \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}" \\\n  --settings \\\n    WEBSITES_ENABLE_APP_SERVICE_STORAGE=false \\\n    DOCKER_ENABLE_CI=true \\\n    ENVIRONMENT=production \\\n    APPINSIGHTS_INSTRUMENTATIONKEY="${INSIGHTS_KEY}"\n\necho ""\necho "=========================================="\necho "Docker App Service Created: ${APP_SERVICE}"\necho "Registry: ${ACR_LOGIN_SERVER}"\necho "URL: https://${APP_SERVICE}.azurewebsites.net"\necho "=========================================="\n```\n\n### Validation\n```bash\n# Verify Resource Group\naz group show --name "${RESOURCE_GROUP}"\n\n# Verify App Service\naz webapp show \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}"\n\n# Check deployment status\naz webapp deployment list \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}" \\\n  --output table\n\n# Get App Service URL\nAPP_URL=$(az webapp show \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}" \\\n  --query "defaultHostName" -o tsv)\n\necho "App URL: https://${APP_URL}"\n\n# Test application\ncurl -s "https://${APP_URL}/" | jq .\n\n# View container logs\naz webapp log tail \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}" \\\n  --provider "docker" \\\n  --tail 20\n\n# Verify ACR repositories\naz acr repository list \\\n  --name "${ACR_REGISTRY}" \\\n  --output table\n\n# List all resources\naz resource list --resource-group "${RESOURCE_GROUP}" --output table\n```\n\n---\n\n## Phase 2: Mid-Day Operations and Management\n\n### Management Operations\n```bash\n# Operation 1: Build and push updated image\ncat > /tmp/app.py <<EOF\nfrom flask import Flask, jsonify\nimport os\n\napp = Flask(__name__)\n\n@app.route(\'/\')\ndef hello():\n    return jsonify({\n        \'message\': \'Azure HayMaker Docker App - UPDATED\',\n        \'version\': \'2.0.0\',\n        \'scenario\': \'webapps-docker-app-service\'\n    })\n\n@app.route(\'/health\')\ndef health():\n    return jsonify({\'status\': \'healthy\', \'version\': \'2.0.0\'})\n\nif __name__ == \'__main__\':\n    app.run(host=\'0.0.0.0\', port=8080)\nEOF\n\ndocker build -t "${ACR_LOGIN_SERVER}/webapp:v2" -f /tmp/Dockerfile /tmp/\ndocker login "${ACR_LOGIN_SERVER}" -u "${ACR_USERNAME}" -p "${ACR_PASSWORD}"\ndocker push "${ACR_LOGIN_SERVER}/webapp:v2"\n\n# Operation 2: Update app to use new image\naz webapp config container set \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}" \\\n  --docker-custom-image-name "${ACR_LOGIN_SERVER}/webapp:v2" \\\n  --docker-registry-server-url "https://${ACR_LOGIN_SERVER}" \\\n  --docker-registry-server-user "${ACR_USERNAME}" \\\n  --docker-registry-server-password "${ACR_PASSWORD}"\n\n# Operation 3: Restart app service\naz webapp restart \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}"\n\n# Operation 4: Monitor container metrics\naz monitor metrics list \\\n  --resource "/subscriptions/$(az account show --query id -o tsv)/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Web/sites/${APP_SERVICE}" \\\n  --metric "CPU%" \\\n  --start-time $(date -u -d \'1 hour ago\' \'+%Y-%m-%dT%H:%M:%SZ\') \\\n  --end-time $(date -u \'+%Y-%m-%dT%H:%M:%SZ\')\n\n# Operation 5: View container logs\naz webapp log tail \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}" \\\n  --provider "docker" \\\n  --tail 50\n\n# Operation 6: Scale up app service\naz appservice plan update \\\n  --name "${APP_SERVICE_PLAN}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --sku B3\n\n# Operation 7: List ACR images\naz acr repository show \\\n  --name "${ACR_REGISTRY}" \\\n  --repository "webapp"\n\n# Operation 8: Enable continuous deployment\n# Note: Requires webhook setup\necho "To enable continuous deployment:"\necho "az webapp deployment container config --resource-group ${RESOURCE_GROUP} --name ${APP_SERVICE}"\n\n# Operation 9: Test different endpoints\ncurl -s "https://${APP_URL}/health" | jq .\ncurl -s "https://${APP_URL}/api/info" | jq .\n\n# Operation 10: Check Application Insights\naz monitor app-insights component show \\\n  --app "${INSIGHTS_NAME}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --query "instrumentationKey" -o tsv\n```\n\n---\n\n## Phase 3: Cleanup and Tear-Down\n\n### Cleanup Steps\n```bash\n# Step 1: Delete app service\naz webapp delete \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --name "${APP_SERVICE}"\n\n# Step 2: Delete app service plan\naz appservice plan delete \\\n  --name "${APP_SERVICE_PLAN}" \\\n  --resource-group "${RESOURCE_GROUP}" \\\n  --yes\n\n# Step 3: Delete the entire resource group\naz group delete \\\n  --name "${RESOURCE_GROUP}" \\\n  --yes \\\n  --no-wait\n\n# Step 4: Verify deletion\nsleep 60\naz group exists --name "${RESOURCE_GROUP}"\n\n# Step 5: Confirm cleanup\necho "Verifying cleanup..."\naz resource list --resource-group "${RESOURCE_GROUP}" 2>&1 | grep "could not be found" && echo "âœ“ Resource group successfully deleted"\n\n# Step 6: Clean up Docker images and local files\ndocker rmi "${ACR_LOGIN_SERVER}/webapp:v1" 2>/dev/null\ndocker rmi "${ACR_LOGIN_SERVER}/webapp:v2" 2>/dev/null\nrm -rf /tmp/Dockerfile /tmp/app.py /tmp/requirements.txt\n```\n\n---\n\n## Resource Naming Convention\n- Resource Group: `azurehaymaker-webapp-docker-${UNIQUE_ID}-rg`\n- App Service: `azurehaymaker-docker-${UNIQUE_ID}`\n- App Service Plan: `azurehaymaker-plan-${UNIQUE_ID}`\n- ACR Registry: `azmkrdocker${UNIQUE_ID}`\n- Application Insights: `azurehaymaker-insights-${UNIQUE_ID}`\n\nAll resources tagged with: `AzureHayMaker-managed=true`\n\n---\n\n## Documentation References\n- [App Service with Containers](https://learn.microsoft.com/en-us/azure/app-service/configure-custom-container)\n- [Docker on App Service](https://learn.microsoft.com/en-us/azure/app-service/quickstart-docker)\n- [Container Registry Integration](https://learn.microsoft.com/en-us/azure/app-service/configure-custom-container?tabs=debian&pivots=container-linux)\n- [Continuous Deployment](https://learn.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment)\n- [App Service CLI Reference](https://learn.microsoft.com/en-us/cli/azure/webapp)\n\n---\n\n## Automation Tool\n**Recommended**: Azure CLI + Docker\n\n**Rationale**: Azure CLI manages App Service lifecycle while Docker handles image building and pushing. This combination provides efficient containerized deployment.\n\n---\n\n## Estimated Duration\n- **Deployment**: 15-20 minutes\n- **Operations Phase**: 8 hours (with image updates and monitoring)\n- **Cleanup**: 5 minutes\n\n---\n\n## Notes\n- App Service runs containers on Linux using Docker\n- Azure Container Registry integration for secure image storage\n- Automatic deployments when new images are pushed\n- No Kubernetes complexity required\n- All operations scoped to single tenant and subscription\n- Suitable for monolithic containerized applications\n- Environment variables for configuration management\n\n\n## Execution Plan\n\n### Phase 1: Test Planning\nPlan test strategy\n**Estimated Duration**: 30 minutes\n**Required Capabilities**: test-design, planning\n\n### Phase 2: Test Implementation\nImplement test cases\n**Estimated Duration**: 30 minutes\n**Required Capabilities**: test-coding, framework-setup\n**Dependencies**: Test Planning\n\n### Phase 3: Test Execution\nRun test suite\n**Estimated Duration**: 30 minutes\n**Required Capabilities**: test-execution, automation\n**Dependencies**: Test Implementation\n\n### Phase 4: Results Analysis\nAnalyze test results\n**Estimated Duration**: 30 minutes\n**Required Capabilities**: analysis, reporting\n**Dependencies**: Test Execution\n\n## Success Criteria\n- Goal \'Scenario: Docker Container on Azure App Service...\' is achieved\n\n## Instructions\nExecute the plan above autonomously:\n1. Follow each phase in sequence\n2. Use available skills and tools\n3. Verify success criteria are met\n4. Report progress and completion',
        "working_dir": ".",
        "sdk": "claude",
        "ui_mode": False,
        "success_criteria": [
            "Goal 'Scenario: Docker Container on Azure App Service...' is achieved"
        ],
        "constraints": [],
    }

    # Read initial prompt
    prompt_path = Path(__file__).parent / "prompt.md"
    if not prompt_path.exists():
        print("Error: prompt.md not found")
        sys.exit(1)

    initial_prompt = prompt_path.read_text()

    # Create auto-mode instance
    auto_mode = AutoMode(
        sdk=config.get("sdk", "claude"),
        prompt=initial_prompt,
        max_turns=config.get("max_turns", 10),
        working_dir=Path(__file__).parent,
        ui_mode=config.get("ui_mode", False),
    )

    # Run agent
    print("Starting testing-scenario:-docker-container-agent...")
    print("Goal: Scenario: Docker Container on Azure App Service")
    print("Estimated duration: 2 hours 36 minutes")
    print()

    exit_code = auto_mode.run()

    if exit_code == 0:
        print("\nGoal achieved successfully!")
    else:
        print(f"\nGoal execution failed with code {exit_code}")

    return exit_code


if __name__ == "__main__":
    sys.exit(main())
